<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Spring Study | 她在学习 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="NieNie">
    
    

    <meta name="description" content="@SpringBootApplication组合了 3 个其他的注解，也就是@Configuration、@EnableAutoConfiguration 和 @ComponentScan @Configuration 它表明我们的这个类将会处理 Spring 的常规配置 @ComponentScan会告诉 Spring 去哪里查找 Spring 组 件（服务、控制器等）。在默认情况下，这个注解">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Study | 她在学习">
<meta property="og:url" content="http://yoursite.com/2017/07/29/Spring-Study/index.html">
<meta property="og:site_name" content="她在学习">
<meta property="og:description" content="@SpringBootApplication组合了 3 个其他的注解，也就是@Configuration、@EnableAutoConfiguration 和 @ComponentScan @Configuration 它表明我们的这个类将会处理 Spring 的常规配置 @ComponentScan会告诉 Spring 去哪里查找 Spring 组 件（服务、控制器等）。在默认情况下，这个注解">
<meta property="og:updated_time" content="2017-08-09T01:26:12.136Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring Study | 她在学习">
<meta name="twitter:description" content="@SpringBootApplication组合了 3 个其他的注解，也就是@Configuration、@EnableAutoConfiguration 和 @ComponentScan @Configuration 它表明我们的这个类将会处理 Spring 的常规配置 @ComponentScan会告诉 Spring 去哪里查找 Spring 组 件（服务、控制器等）。在默认情况下，这个注解">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">她在学习</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Spring Study</h1>

    

    <div class="post-meta">
      <time datetime="2017-07-29" class="post-meta__date date">2017-07-29</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <ol>
<li><p>@SpringBootApplication组合了 3 个其他的注解，也就是@Configuration、@EnableAutoConfiguration 和 @ComponentScan</p>
<p>@Configuration 它表明我们的这个类将会处理 Spring 的常规配置</p>
<p>@ComponentScan会告诉 Spring 去哪里查找 Spring 组 件（服务、控制器等）。在默认情况下，这个注解将会扫描当前包以及该包下面的所有子包。</p>
<p>@EnableAutoConfiguration 会指导 Spring Boot 发挥其 魔力。如果你将其移除掉的话，就无法从 Spring Boot 的自动配置中收益了。</p>
</li>
<li><p>Spring Boot 来编写 MVC 应用的第一步通常是在代码中添加控制器。将控制器放 到 controller 子包中，这样它就能够被@ComponentScan 注解所发现</p>
</li>
<li><p>src/main/resources/ application.properties 中的一些配置</p>
<p>debug=true 配置debug模式</p>
<p>server.port = 8081 配置端口 通过将该变量设置为−1，可以禁用 HTTP，或者将其配置为 0，这样的话，就会在随机 的端口上启动应用。<br>server.contextPath = /demo  配置路径</p>
</li>
<li><p>IoC</p>
<p>将类与类之间的依赖从代码中脱离出来，用配置的方式进行依赖关系描述，由此容器负责依赖类之间的创建、拼接、管理、获取等工作。</p>
<p>BeanFactory接口是Spring框架的核心接口。</p>
<p>Context模块构建于核心模块之上，拓展了BeanFactory的功能。</p>
<p>表达式语言模块是统一表达式语言的一个拓展，该表达式语言用于查询和管理运行期的对象</p>
</li>
<li><p>AOP</p>
<p>是进行横切逻辑编程的思想，开拓了考虑问题的思路。在这个模块中Spring提供了满足AOP Alliancea规范的实现，还整合了AspectJ这种AOP语言级的框架。在Java 5.0引入了java.lang.instrument ，允许在JVM启动时启用一个代理类，在运行期修改类的字节码，改变一个类的功能，从而实现AOP的功能。</p>
</li>
<li><p>@Conditional注解：类似于@Profile，一般用于在多个环境（开发环境，测试环境，正式机环境）中进行配置切换，即通过某个配置来开启某个环境。优点是允许自己定义规则。可以指定在如@Component、@Bean、@Configuration等注解的类上，以决定是否创建Bean等</p>
</li>
<li><p>领域对象（Domain Object）也被称为实体类，代表了业务的状态，且贯穿展现层、业务层和持久层，最终被持久化到数据库中。领域对象不一定等同于数据库表，不过对于简单的应用来说，领域对象往往拥有对应的数据库表。</p>
</li>
<li><p>持久层的主要工作就是从数据库表中加载数据并实例化领域对象，或将领域对象持久化到数据库表中。</p>
</li>
<li><p>在Dao中使用JdbcTemplate#query()方法，该方法的签名为query(String sql,Object[] args,RowCallbackHandler rch)，有三个入参。</p>
<ul>
<li>sqlStr:查询的SQL语句，允许使用带“？”的参数占位符</li>
</ul>
</li>
</ol>
<ul>
<li>args:SQL语句中占位符对应的参数数组</li>
<li>RowCallbackHandler:查询结果的处理回调接口，该回调接口有一个方法processRow(ResultSet rs)负责将查询的结果从ResultSet装载到类似于领域对象的对象实例中。</li>
</ul>
<ol>
<li><p>在DAO中编写SQL语句时，通常将SQL语句写在类静态变量中，会使代码更具有可读性。多行SQL语句在每行SQL语句的句前和句尾都加一个空格，这样就可以避免分行SQL语句组合后的错误。</p>
</li>
<li><p>ModelAndView的第一个参数代表视图的逻辑名，第二、三个参数分别为数据模型名称和数据模型对象，数据模型对象将以数据模型名称为参数名放置到request的属性中</p>
</li>
<li><p>InternalResourceViewResolver，通过为视图逻辑名添加前、后缀的方法进行解析。</p>
</li>
<li><p>在Spring Boot中，使用事务非常简单，首先在主类Application上标注@EnableTransactionManagement注解（开启事务支持，相当于XML中的\<tx:annotationdriven>配置方式），然后在访问Service方法上标注@Transactional即可。如果标注在类上，会Service类的所有方法都被事务增强。</tx:annotationdriven></p>
</li>
<li><p>IoC是Spring容器的内核，AOP、声明式事务等功能再次基础上开花结果。对于软件来说，即某一接口具体实现类的选择权从调用类中移除，转交到第三方决定，即由Spring容器借由Bean配置来进行控制</p>
</li>
<li><p>IoC的类型</p>
<ol>
<li><p>构造函数注入</p>
<p>在类中声明变量，通过构造函数，将结构实现类通过构造函数变量传入。</p>
</li>
<li><p>属性注入</p>
<p>属性注入可以有选择地通过Setter方法完成调用类所需依赖的注入，更加灵活方便</p>
</li>
<li><p>接口注入</p>
<p>将调用类所有依赖注入的方法抽取到一个接口中</p>
</li>
</ol>
</li>
<li><p>JVM装载类时使用“全盘负责委托机制”，“全盘负责”是指当一个ClassLoader装载一个类时，除非显式地使用另一个ClassLoader，该类所依赖及引用的类也由这个ClassLoader载入；“委托机制”是指委托父装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类。</p>
</li>
<li><p>类文件被装载并解析后，在JVM内将拥有一个对应的java.lang.Class类描述对象，该类的实例都拥有指向这个类描述对象的引用，而类描述对象又拥有指向关联ClassLoader的引用。</p>
</li>
<li><h3 id="Java的反射机制"><a href="#Java的反射机制" class="headerlink" title="Java的反射机制"></a>Java的反射机制</h3></li>
</ol>
<pre><code>Constructor:类的构造函数反射类，通过Class#getConstructors()方法可以获取类的所有构造函数反射对象数组。一个主要的方法是newInstance(Object[] initargs)，通过该方法可以创建一个对象类的实例，相当于new关键字。

Method:类方法的反射类，通过Class#getDeclaredMethods()方法可以获取类的所有方法反射类对象数组Method[]。可以通过getDeclaredMethod(String name,Class...parameterTypes)获取特定签名的方法，其中name为方法名，Class为方法入参类型列表。Method最主要的方法是invoke(Object obj,Object[] args)，其中Obj表示操作的目标对象；args为方法入参。还有很多用于获取类方法更多信息的方法：

- Class getReturnType()  获取方法的返回值类型
- Class[] getParameterTypes()  获取方法的入参类型数组
- Class[] getExceptionTypes()  获取方法的异常类型数组
- Annotation\[][] getParameterAnnotations() 获取方法的注解信息，是Java5.0中的新方法

Field:类成员变量的反射类，通过Class#getDeclaredFields()方法可以获取类的成员变量反射对象数组，通过Class#getDeclaredField(String name)则可以获取某个特定名称的成员变量反射对象。Field类最主要的方法是set(Object obj,Object value)，其中obj表示操作的目标对象，通过value为目标对象的成员变量设置值

在访问private或protected成员变量和方法时，必须通过setAccessible(boolean access)方法取消Java语言检查
</code></pre><ol>
<li><h5 id="Resource接口的主要方法"><a href="#Resource接口的主要方法" class="headerlink" title="Resource接口的主要方法"></a>Resource接口的主要方法</h5></li>
</ol>
<pre><code>boolean exists()  资源是否存在

boolean isOpen()  资源是否打开

URL getURL()throws IOException  如果底层资源可以表示成URL，则该方法返回对应的URL对象

File getFile() throws IDException  如果底层资源对应一个文件，则该方法返回对应的文件对象

InputStream getInputStream()  throws IOException 返回资源对应的输入流

##### 通过资源地址的特殊标识就可以访问相应的资源：

classpath:  从类路径中加载资源，都是相对于类的根路径。资源文件可以在标准的文件系统中，也可以在JAR或ZIP的类包中

file:     从UrlResource从文件系统目录中装载资源，可采用绝对或相对路径

http://   使用UrlResource从WEB服务器中装载资源

ftp://  使用UrlResource从ftp服务器中装载资源

没有前缀 根据ApplicationContext的具体实现类采用对应类型的Resource

其中，和“classpath:”对应的还有另一种比较难理解的“classpath*:”前缀。前者只能加载找到的第一个文件，而后者是为了从多个jar文件中加载相同的文件。

Ant风格的资源地址支持3中匹配符：

​    ？：一个字符

​    *：任意字符

​    **：多层路径
</code></pre><ol>
<li><h5 id="如果在-中指定Bean的作用范围为scope-”prototype”-则将Bean返回给调用者，调用者负责Bean后续生命的管理，Spring不再管理这个Bean的生命周期。如果将作用范围设置为scope-”singleton”，则将Bean放入IoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对这些Bean进行后续的生命管理。"><a href="#如果在-中指定Bean的作用范围为scope-”prototype”-则将Bean返回给调用者，调用者负责Bean后续生命的管理，Spring不再管理这个Bean的生命周期。如果将作用范围设置为scope-”singleton”，则将Bean放入IoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对这些Bean进行后续的生命管理。" class="headerlink" title="如果在\中指定Bean的作用范围为scope=”prototype”,则将Bean返回给调用者，调用者负责Bean后续生命的管理，Spring不再管理这个Bean的生命周期。如果将作用范围设置为scope=”singleton”，则将Bean放入IoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对这些Bean进行后续的生命管理。"></a>如果在\<bean>中指定Bean的作用范围为scope=”prototype”,则将Bean返回给调用者，调用者负责Bean后续生命的管理，Spring不再管理这个Bean的生命周期。如果将作用范围设置为scope=”singleton”，则将Bean放入IoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对这些Bean进行后续的生命管理。</bean></h5></li>
</ol>
<ol>
<li><h5 id="xmlns-””-默认命名空间"><a href="#xmlns-””-默认命名空间" class="headerlink" title="xmlns=”” //默认命名空间"></a>xmlns=”” //默认命名空间</h5><h5 id="xmlns-xsi-””-xsi标准命名空间"><a href="#xmlns-xsi-””-xsi标准命名空间" class="headerlink" title="xmlns:xsi=””  //xsi标准命名空间"></a>xmlns:xsi=””  //xsi标准命名空间</h5><p>xsi:schemaLocation=””   //为每个命名空间指定具体的Schema文件</p>
<p>如果命名空间的别名为空，则表示该命名空间为文档默认命名空间。</p>
</li>
</ol>
<ol>
<li><h5 id="Bean基本配置"><a href="#Bean基本配置" class="headerlink" title="Bean基本配置"></a>Bean基本配置</h5></li>
</ol>
<pre><code>一般情况下Spring IoC容器中的一个Bean对应配置文件中的一个\&lt;bean&gt;，eg: \&lt;bean id=&quot;foo&quot; class=&quot;com.smart.Foo&quot; /&gt; id为这个Bean的名称，通过容器的getBean(&quot;Foo&quot;)即可获取对应的Bean

id和name都可以指定多个名字

配置文件不允许出现两个相同id的\&lt;bean&gt;，但可以出现两个相同name。如果有多个name相同的，那么通过getBean(beanName)获取Bean时，将返回后面声明的那个Bean。因为覆盖。所以为了避免无意间Bean覆盖的隐患，应尽量使用id而非name命名Bean

如果id和name两个属性都未指定，这将全限定类名作为Bean的名称。如果存在多个实现类相同的匿名，则通过getBean(&quot;co.smart.simple.Car#1&quot;)//第二个。第一个没有井号 

##### 依赖注入

属性注入 通过Set...

​<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;car&quot; class=&quot;com.smart.ditype.Car&quot;&gt;</div><div class="line">	&lt;property name=&quot;maxSpeed&quot;&gt;&lt;value&gt;200&lt;/value&gt;&lt;/property&gt;	</div><div class="line">&lt;/bean&gt;</div><div class="line">​</div></pre></td></tr></table></figure>


构造函数注入（按类型匹配入参）(配置文件采用和元素标签顺序无关的策略)

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;car1&quot; class=&quot;com.smart.ditype.Car&quot;&gt;</div><div class="line">&lt;constructor-arg type=&quot;java.lang.String&quot;&gt;</div><div class="line">&lt;value&gt;红旗CA72&lt;/value&gt;</div><div class="line">&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>


    构造函数注入（按索引匹配入参） 避免相同类型，消除不确定性（索引从1开始）

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;car1&quot; class=&quot;com.smart.ditype.Car&quot;&gt;</div><div class="line">&lt;constructor-arg index=&quot;0&quot; value=&quot;红旗&quot; /&gt;</div><div class="line">&lt;constructor-arg index=&quot;1&quot; value=&quot;中国一汽&quot; /&gt;</div><div class="line">&lt;constructor-arg index=&quot;2&quot; value=&quot;20000&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>


如果拥有重载的构造函数，只有最后一个入参不一致，则联合类型和索引匹配入参

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;car1&quot; class=&quot;com.smart.ditype.Car&quot;&gt;</div><div class="line">&lt;constructor-arg index=&quot;0&quot;  type=&quot;java.lang.String&quot;&gt;</div><div class="line">&lt;value&gt;红旗CA72&lt;/value&gt;</div><div class="line">&lt;/constructor-arg&gt;</div><div class="line">&lt;constructor-arg index=&quot;1&quot;  type=&quot;java.lang.String&quot;&gt;</div><div class="line">&lt;value&gt;红旗CA72&lt;/value&gt;</div><div class="line">&lt;/constructor-arg&gt;</div><div class="line">&lt;constructor-arg index=&quot;2&quot;  type=&quot;int&quot;&gt;</div><div class="line">&lt;value&gt;200&lt;/value&gt;</div><div class="line">&lt;/constructor-arg&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>


##### 工厂方法注入

工厂类负责创建一个或多个目标类实例，工厂类方法一般以接口或抽象类变量的形式返回目标类实例。静态工厂方法比非静态工厂方法更易使用。

​<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=“car6” class=&quot;com.smart.ditype.CarFactory&quot; factory-method=&quot;createCar&quot;/&gt;</div><div class="line">​</div></pre></td></tr></table></figure>


直接通过class属性指定工厂类，然后再通过factory-method指定对应的工厂方法
</code></pre><ol>
<li><p>XML中共有5个特殊字符，分别是&amp;,&lt;,&gt;,”,’.如果配置文件的注入值包括这些特殊字符，就需要特别处理。采用\&lt;![CDATA[]]&gt;标签，把包含特殊字符的字符串封装起来。或采用XML转义序列表示这些特殊字符。</p>
</li>
<li><p>在XML中可以通过ref元素添加引用，建立依赖</p>
<p>可以通过以下属性引用容器中的其他Bean</p>
<ul>
<li>bean:通过该属性可以引用同一容器或父容器中的Bean，这是最常见的形式</li>
<li>local:通过该属性只能引用同一配置文件中定义的Bean，可以利用XML解析器自动检验引用的合法性。</li>
<li>parent:引用父容器中的Bean，如\<ref parent="car">的配置说明car的Bean是父容器中的Bean</ref></li>
</ul>
</li>
<li><p>为属性设置null值，使用标签\<null></null></p>
</li>
<li><p>集合合并。允许子bean继承父bean的同名属性集合元素。在\<set>里面加上merge=”true”属性。如果为false，则不会进行合并</set></p>
</li>
<li><p>未采用p命名空间前，使用\<property>子元素配置Bean的属性；采用p命名空间后，采用\<bean>的元素属性配置Bean的属性</bean></property></p>
<p>对于字面值属性，其格式为</p>
<p>p:\&lt;属性名&gt;=”xxx”</p>
<p>对于引用对象的属性，其格式为：</p>
<p>p:\&lt;属性名&gt;-ref=”xxx”</p>
<p> 正是由于P命名空间中的属性名是可变的，所以p命名空间没有对应的Schema定义文件。</p>
</li>
<li><p>用于替换他人的Bean必须实行MethodReplacer接口，Spring将利用该接口的方法去替换目标Bean的方法。并在配置时用替换类的方法去替换被替换类的方法。\<replaced-method name="被替换方法名" replacer="替换的类"> </replaced-method></p>
</li>
<li><p>配置信息时，通过父子\<bean>的继承关系就可以很好的消除重复的配置信息。abstract=”true”</bean></p>
</li>
<li><p>可以通过\<idref>标签引用另一个\<bean>的名字，在容器启动时，Spring负责检查引用关系的正确性，就可以提前发现错误。</bean></idref></p>
</li>
<li><p>@Component 可以对类进行标注，能被容器识别</p>
<p>@Repository 用于对DAO实现类进行标注</p>
<p>@Service 用于对Service实现类进行标注</p>
<p>@Controller 用于对Controller实现类进行标注</p>
<p>@Autowired Bean的依赖注入（如果希望找不到匹配的Bean完成注入也不要抛出异常，那么可以使用@Autowired(required=false)</p>
<p>@Qualifier 如果有一个以上匹配的Bean时，可以通过@Qualifier限定Bean的名称</p>
</li>
<li><p>@responsebody表示该方法的返回结果直接写入HTTP response body中<br>一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。</p>
</li>
</ol>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
